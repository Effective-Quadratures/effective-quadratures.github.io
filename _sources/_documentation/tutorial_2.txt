Foundations II: Orthogonal polynomials
========================================
There is an intimate relationship between orthogonal polynomials and quadrature points. In this tutorial, we demonstrate how one can use Effective Quadratures to compute univariate quadrature rules. For multivariate quadrature points and weights, please check out the tutorials on *Sparse and tensor grid quadrature rules*.


Consider the task of integrating the function

.. math::

	I = \int_{-1}^{1} f\left( s \right) \rho \left( s \right) ds

where the measure :math:`\rho \left( s \right)` is the uniform distribution over :math:`[-1,1]`. Our task is to numerically approximate this integral using a quadrature rule, i.e.,

.. math::

	I \approx 2 \sum_{i=1}^{N} f\left( \lambda_{i} \right) \omega_i

where the pair :math:`\left\{ \lambda_{i} , \omega_i  \right\}_{i=1}^{N}` represents an N-point quadrature rule. The constant :math:`2` arises because we are integrating over the range of 2 and our quadrature weights sum up to :math:`1`. To obtain such points in Effective Quadratures, one uses the following commands.

.. code::

	from equadratures import *
	import numpy as np

	order = 4
	myParameter = Parameter(lower=-1, upper=1, order=order, distribution='Uniform')
	myBasis = Basis('Univariate')
	myPoly = Poly(myParameter, myBasis, method='numerical-integration')
	points, weights = myPoly.get_points_and_weights()

The above quadrature rule is known as *Gauss-Legendre*. In practice if one wishes to evaluate an integral, the weights must be scaled depending on the domain of integration. Let :math:`f(x) = x^7 - 3x^6 + x^5 - 10x^4 + 4` be our function of choice, defined over the domain :math:`[-1,1]`. The analytical integral for this function is 22/7. Now using our 5-point Gauss-Legendre quadrature rule, we obtain

.. code::

	def function(x):
    		return x[0]**7 - 3.0*x[0]**6 + x[0]**5 - 10.0*x[0]**4 +4.0

	integral = float( 2  * np.dot(weights , evaluate_model(points, function) ) )
	print integral
	>> 3.14285714


which is equivalent to 22/7. Note that the constant 2 arises because we are integrating over :math:`[-1,1]` with the uniform measure, which has a density of 1/2.

Now, in addition to standard Gauss-Christoffel quadrature rules (i.e., substitute different distributions in the definition of Parameter), Effective Quadratures also has Gauss-Christoffel-Lobatto rules, which feature end-points and Gauss-Christoffel-Radau rules, which feature either the upper or lower end-points. As an example, consider the following

.. code::

	myParameter = Parameter(lower=-1,upper=1,order=order,distribution='uniform',endpoints='both')
	myBasis = Basis('Univariate')
	myPoly = Polyint(myParameter2, myBasis2, method='numerical-integration')
	points, weights = myPoly.get_points_and_weights()


.. figure:: Figures/tutorial_2_fig_a.png
   :scale: 30 %

   Figure. A comparison of order 4 Gauss-Legendre quadrature points (circles) with order 4 Gauss-Legendre-Lobatto points (squares) and Gauss-Legendre-Radau (triangles).

To verify the accuracy of these points, we use the same code as above.

.. code::

	s2 = Parameter(lower=-1, upper=1, order=order, distribution='uniform', endpoints='lower')
	s3 = Parameter(lower=-1, upper=1, order=order, distribution='uniform', endpoints='upper')
	s4 = Parameter(lower=-1, upper=1, order=order, distribution='uniform', endpoints='both')

	myPoly2 = Poly(s2, myBasis, method='numerical-integration')
	myPoly3 = Poly(s3, myBasis, method='numerical-integration')
	myPoly4 = Poly(s4, myBasis, method='numerical-integration')

	integral2 = float( 2  * np.dot(weights2 , evaluate_model(points2, function) ) )
	integral3 = float( 2  * np.dot(weights3 , evaluate_model(points3, function) ) )
	integral4 = float( 2  * np.dot(weights4 , evaluate_model(points4, function) ) )
	print(integral2, integral3, integral4)
	>> 3.1428571428571375 3.142857142857139 3.1428571428571535

The full source code for this tutorial can be found `here. <https://github.com/Effective-Quadratures/Effective-Quadratures/blob/master/source/_documentation/codes/tutorial_2.py>`__

Index-sets
--------------
This notebook covers multi-indices: a key ingredient in constructing multivariate polynomials. There are five different types of index sets in Effective Quadratures:


.. list-table:: Multi-index sets in Effective Quadratures.
   :widths: 10 25 60
   :header-rows: 1

   * - Option
     - Index set
     - Parameters
   * - 1
     - Tensor grid
     - List of max. individual orders
   * - 2
     - Total order
     - List of max. individual orders
   * - 3
     - Sparse grid
     - Growth rule and level parameter
   * - 4
     - Hyperbolic basis
     - List of max. individual orders and a truncation parameter
   * - 5
     - Euclidean degree
     - List of max. individual orders

In what follows, we will briefly demonstrate how we construct them and plot them.

.. code::

	from equadratures import *
	import numpy as np

We begin by defining a tensor grid index set in three dimensions:

.. code::

	tensor = Basis('tensor-grid', [4,4,4])
	elements = tensor.elements

	# Plot!
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	ax.scatter(elements[:,0], elements[:,1], elements[:,2],  marker='s', s=80, color='crimson')
	ax.set_xlabel('$i_i$')
	ax.set_ylabel('$i_2$')
	ax.set_zlabel('$i_3$')
	plt.savefig('Basis_tensor.png' , dpi=200, bbox_inches='tight', pad_inches=0.1)

.. figure:: Figures/tutorial_5_fig_a.png
   :scale: 40 %

    Figure. Tensor multi-index set.


It is readily apparent that the tensor grid index set has virtually every element within the order [4,4,4] cube. Lets suppose that one does not want to afford :math:`4^3` computations, necessary to approximate all the coefficients associated with a tensor index set multivariate polynomial. One can then opt for a sparse grid, which are select linear combination of select tensor products. In Effective Quadratures, they can be declared as follows:

.. code:

  sparse = Basis('sparse-grid', level=2, growth_rule='linear')
  sparse.dimension = 3
  a, b, c = sparse.getBasis()
  print(a)

	>> [[0. 0. 2.]
 	[0. 0. 3.]
 	[0. 0. 4.]
 	[0. 1. 1.]
 	[0. 1. 2.]
 	[0. 1. 3.]
 	[0. 2. 0.]
 	[0. 2. 1.]
 	[0. 2. 2.]
 	[0. 3. 0.]
 	[0. 3. 1.]
 	[0. 4. 0.]
 	[1. 0. 1.]
 	[1. 0. 2.]
 	[1. 0. 3.]
 	[1. 1. 0.]
 	[1. 1. 1.]
 	[1. 1. 2.]
 	[1. 2. 0.]
 	[1. 2. 1.]
 	[1. 3. 0.]
 	[2. 0. 0.]
 	[2. 0. 1.]
 	[2. 0. 2.]
 	[2. 1. 0.]
 	[2. 1. 1.]
 	[2. 2. 0.]
	[3. 0. 0.]
 	[3. 0. 1.]
 	[3. 1. 0.]
 	[4. 0. 0.]]

Here :math:`a` are the select tensor product grids used, and :math:`b` are the linear coefficients used when combining the tensor product grids. While the code can perform integrations and coefficient approximation using sparse grids, we recommend users to stick to the effective subsampling approach that uses least squares. In both theory and practice, the results are identical. We now move on to the three other index sets: Total order, Euclidean and a Hyperbolic basis.

.. code::

	euclid = Basis('euclidean-degree', [4,4,4])

.. figure:: Figures/tutorial_5_fig_b.png
   :scale: 40 %

   Figure. Euclidean degree multi-index set.


.. code::

	total = Basis('total-order', [4,4,4])

.. figure:: Figures/tutorial_5_fig_c.png
   :scale: 40 %

   Figure. Total order multi-index set.

And finally the hyperbolic one:


.. code::

	hyper = Basis('hyperbolic-basis', [4,4,4], q=0.5)

.. figure:: Figures/tutorial_5_fig_d.png
   :scale: 40 %

   Figure. Hyperbolic basis multi-index set.

The hyperbolic basis takes in a q value, which varies between 0.1 and 1.0. Feel free to play around with this parameter and see what the effect on the total number of basis terms are. This is known as the cardinality of the index set. 


Orthogonal polynomials
-----------------------
In this tutorial we describe how one can construct orthogonal polynomials in Effective Quadratures. For starters, we consider Legendre polynomials---orthogonal with respect to the uniform weight function. We define a Parameter :math:`s` with :math:`\rho(s) \sim \mathcal{U}[-1,1]`.


.. code::

	from equadratures import *
	import numpy as np
	import matplotlib.pyplot as plt


	order = 5
	s1 = Parameter(lower=-1, upper=1, order=order, distribution='Uniform')

We restrict our attention to the first five orthogonal polynomials, where the parameterized matrix :math:`\mathbf{P}` has the form

.. math::

	\mathbf{P}\left(i,j\right)=\psi_{i}\left(\lambda_{j}\right) \; \; \text{where} \; \; i=1, \ldots, p; \; j = 1, \ldots, N,

where :math:`N` is the number of points :math:`\lambda_{j}` discretizing the domain of :math:`s`, and :math:`p` is the maximum polynomial order, set to 5. Plots of the polynomials are shown below.

.. code::

	myBasis = Basis('univariate')
	myPoly = Poly(s1, myBasis, method='numerical-integration')
	xo = np.linspace(-1., 1, 100)
	P = myPoly.get_poly(xo)

	fig = plt.figure()
	ax = fig.add_subplot(1,1,1)
	plt.plot(xo, P[0,:], lw=2, label='Order 0')
	plt.plot(xo, P[1,:], lw=2, label='Order 1')
	plt.plot(xo, P[2,:], lw=2, label='Order 2')
	plt.plot(xo, P[3,:], lw=2, label='Order 3')
	plt.plot(xo, P[4,:], lw=2, label='Order 4')
	plt.plot(xo, P[5,:], lw=2, label='Order 5')
	plt.legend(loc='upper center', bbox_to_anchor=(0.5, 1.30), ncol=3, fancybox=True, shadow=True)
	plt.xlabel('$s$', fontsize=18)
	plt.ylabel('Polynomials', fontsize=18)
	plt.savefig('../Figures/tutorial_3_fig_a.png', dpi=200, bbox_inches='tight')



.. figure:: Figures/tutorial_3_fig_a.png
   :scale: 30 %

   Figure. The first six Legendre polynomials

A few remarks are in order regarding this plot. Standard Legendre polynomials are orthogonal via

.. math::

	\int_{-1}^{1}\psi_{i}\left(s \right)\psi_{j}\left(s \right)ds=\frac{2\delta_{ij}}{2i+1},

where :math:`\delta_{ij}` is the Kronecker delta. In Effective Quadratures, we modify all orthogonal polynomials such that the right hand side of this expression is unity when :math:`i=j`

.. math::

	\frac{1}{2i+1} \int_{-1}^{1}\psi_{i}\left(s\right)\psi_{j}\left(s\right) ds \\
	=\int_{-1}^{1}\frac{1}{\sqrt{2i+1}}\psi_{j}\left(s\right)\frac{1}{\sqrt{2j+1}}\psi_{j}\left(s\right)ds \\
	=\delta ij

Introducing these scaling factors, we now can plot the standard Legendre polynomials; these are reported in the Wikipedia `entry <https://en.wikipedia.org/wiki/Legendre_polynomials>`__.


.. code::

	factor_0 = 1.
	factor_1 = 1.0 / np.sqrt(2.0 * 1.0 + 1.)
	factor_2 = 1.0 / np.sqrt(2.0 * 2.0 + 1.)
	factor_3 = 1.0 / np.sqrt(2.0 * 3.0 + 1.)
	factor_4 = 1.0 / np.sqrt(2.0 * 4.0 + 1.)
	factor_5 = 1.0 / np.sqrt(2.0 * 5.0 + 1.)

	fig = plt.figure()
	ax = fig.add_subplot(1,1,1)
	plt.plot(xo, factor_0 * P[0,:], lw=2, label='Order 0')
	plt.plot(xo, factor_1 * P[1,:], lw=2, label='Order 1')
	plt.plot(xo, factor_2 * P[2,:], lw=2, label='Order 2')
	plt.plot(xo, factor_3 * P[3,:], lw=2, label='Order 3')
	plt.plot(xo, factor_4 * P[4,:], lw=2, label='Order 4')
	plt.plot(xo, factor_5 * P[5,:], lw=2, label='Order 5')
	plt.legend(loc='upper center', bbox_to_anchor=(0.5, 1.30), ncol=3, fancybox=True, shadow=True)
	plt.xlabel('$s$', fontsize=18)
	plt.ylabel('Scaled polynomials', fontsize=18)
	plt.savefig('../Figures/tutorial_3_fig_b.png', dpi=200, bbox_inches='tight')

.. figure:: Figures/tutorial_3_fig_b.png
   :scale: 30 %

   Figure. The first six (normalized) Legendre polynomials
